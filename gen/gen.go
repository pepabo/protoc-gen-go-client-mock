package gen

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/pepabo/protoc-gen-go-client-mock/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	optPackage     = "package"
	optSamePackage = "same_package"
)

type Generator struct {
	genp        *protogen.Plugin
	samePackage bool
	packageName string
}

func New(genp *protogen.Plugin) *Generator {
	genp.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	return &Generator{
		genp: genp,
	}
}

func (gen *Generator) Generate() error {
	if err := gen.parseOpts(); err != nil {
		return err
	}
	var tmppf *protogen.File
	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		tmppf = pf
	}
	filename := filepath.Join(filepath.Dir(tmppf.GeneratedFilenamePrefix), "client_mock.go")
	g := gen.genp.NewGeneratedFile(filename, tmppf.GoImportPath)

	g.P("// Code generated by protoc-gen-go-client-mock. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-client-mock v%s", version.Version))
	g.P("")

	if gen.packageName != "" {
		g.P("package ", gen.packageName)
	} else {
		g.P("package ", tmppf.GoPackageName)
	}
	g.P("")
	g.P(`import (`)
	if !gen.samePackage {
		g.P(fmt.Sprintf("%s %s", tmppf.GoPackageName, tmppf.GoImportPath.String()))
	}
	//g.P(`"reflect"`)
	g.P("")
	g.P(`"github.com/golang/mock/gomock"`)
	//g.P(`"google.golang.org/grpc"`)
	g.P(`)`)
	g.P("")

	g.P("var _ Client = (*MockClient)(nil)")
	g.P("")

	g.P("// MockClient is a mock of Client interface.")
	g.P("type MockClient struct {")
	g.P("ctrl     *gomock.Controller")
	g.P("recorder *MockClientMockRecorder")
	g.P("}")
	g.P("")

	g.P("// MockClientMockRecorder is the mock recorder for MockClient.")
	g.P("type MockClientMockRecorder struct {")
	g.P("mock *MockClient")
	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		for _, s := range pf.Services {
			if gen.samePackage {
				g.P(fmt.Sprintf("mock%s *Mock%sClient", string(s.Desc.FullName().Name()), s.Desc.FullName().Name()))
			} else {
				g.P(fmt.Sprintf("mock%s *%s.Mock%sClient", string(s.Desc.FullName().Name()), tmppf.GoPackageName, s.Desc.FullName().Name()))
			}
		}
	}
	g.P("}")
	g.P("")

	g.P("// NewMockClient creates a new mock instance.")
	g.P("func NewMockClient(ctrl *gomock.Controller) *MockClient {")
	g.P("mock := &MockClient{ctrl: ctrl}")
	g.P("mock.recorder = &MockClientMockRecorder{")
	g.P("mock: mock,")
	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		for _, s := range pf.Services {
			if gen.samePackage {
				g.P(fmt.Sprintf("mock%s: NewMock%sClient(ctrl),", string(s.Desc.FullName().Name()), s.Desc.FullName().Name()))
			} else {
				g.P(fmt.Sprintf("mock%s: %s.NewMock%sClient(ctrl),", string(s.Desc.FullName().Name()), tmppf.GoPackageName, s.Desc.FullName().Name()))
			}
		}
	}
	g.P("}")
	g.P("return mock")
	g.P("}")

	g.P("// EXPECT returns an object that allows the caller to indicate expected use.")
	g.P("func (m *MockClient) EXPECT() *MockClientMockRecorder {")
	g.P("return m.recorder")
	g.P("}")
	g.P("")

	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		for _, s := range pf.Services {
			if gen.samePackage {

				g.P(fmt.Sprintf("func (m *MockClient) %s() %sClient {", s.Desc.FullName().Name(), s.Desc.FullName().Name()))
				g.P("m.ctrl.T.Helper()")
				g.P(fmt.Sprintf("return m.recorder.mock%s", s.Desc.FullName().Name()))
				g.P("}")
				g.P("")

				g.P(fmt.Sprintf("func (mr *MockClientMockRecorder) %s() *Mock%sClientMockRecorder {", s.Desc.FullName().Name(), s.Desc.FullName().Name()))
				g.P("mr.mock.ctrl.T.Helper()")
				g.P(fmt.Sprintf("return mr.mock%s.EXPECT()", s.Desc.FullName().Name()))
				g.P("}")
				g.P("")

			} else {
				panic("not implemented")
			}
		}
	}

	return nil
}

func (gen *Generator) parseOpts() error {
	opts := strings.Split(gen.genp.Request.GetParameter(), ",")
	for _, o := range opts {
		o := strings.TrimSpace(o)
		switch {
		case o == optSamePackage:
			gen.samePackage = true
		case strings.HasPrefix(o, fmt.Sprintf("%s=", optPackage)):
			gen.packageName = strings.TrimPrefix(o, fmt.Sprintf("%s=", optPackage))
		}
	}
	if gen.samePackage && gen.packageName != "" {
		return errors.New("package name cannot be specified if it is the same package as the Go package")
	}
	return nil
}

func toLowerCamel(s string) string {
	runes := []rune(s)
	if len(runes) > 0 {
		runes[0] = unicode.ToLower(runes[0])
	}
	return string(runes)
}
